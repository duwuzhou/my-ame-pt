<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2048 小游戏</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    :root { --gap: 12px; --radius: 14px; }
    body {
      background: radial-gradient(1400px 700px at 15% -10%, #e1f2ff 0%, #cfe5ff 30%, #a9ccff 60%, #87afff 80%, #6f98ff 100%);
    }
    .board {
      touch-action: none;
      background: linear-gradient(140deg, #d7ecff 0%, #8ec0ff 45%, #5187ff 100%);
      border-radius: var(--radius);
      padding: var(--gap);
      box-shadow: 0 18px 45px rgba(28, 80, 192, 0.35);
    }
    .cell {
      background: rgba(255, 255, 255, 0.45);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }
    .tile {
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-weight: 800;
      line-height: 1;
      user-select: none;
      box-shadow: inset 0 -2px 0 rgba(15,23,42,0.08), 0 10px 24px rgba(30, 64, 175, 0.24);
      transform: translateZ(0);
      transition: transform 120ms ease, filter 120ms ease;
    }
    @keyframes pop {
      0% { transform: scale(0); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes merge {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); filter: brightness(1.2); }
      100% { transform: scale(1); }
    }
    .tile.pop { animation: pop 200ms ease-out forwards; }
    .tile.merge { animation: merge 140ms ease-in-out forwards; }

    /* 蓝色主题的方块颜色 */
    .t2    { background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); color:#0f172a; }
    .t4    { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); color:#0f172a; }
    .t8    { background: linear-gradient(135deg, #c3dbff 0%, #9cc4ff 100%); color:#0b1f3a; }
    .t16   { background: linear-gradient(135deg, #9cc4ff 0%, #7ab0ff 100%); color:#ffffff; }
    .t32   { background: linear-gradient(135deg, #7ab0ff 0%, #5c97ff 100%); color:#ffffff; }
    .t64   { background: linear-gradient(135deg, #5c97ff 0%, #467cf4 100%); color:#ffffff; }
    .t128  { background: linear-gradient(135deg, #467cf4 0%, #3563e9 100%); color:#ffffff; }
    .t256  { background: linear-gradient(135deg, #3563e9 0%, #284dd3 100%); color:#ffffff; }
    .t512  { background: linear-gradient(135deg, #284dd3 0%, #1e3fb6 100%); color:#ffffff; }
    .t1024 { background: linear-gradient(135deg, #1e3fb6 0%, #182f8f 100%); color:#ffffff; }
    .t2048 { background: linear-gradient(135deg, #182f8f 0%, #0f1e63 100%); color:#ffffff; }
    .t4096 { background: linear-gradient(135deg, #0f1e63 0%, #081233 100%); color:#ffffff; }
    .t8192 { background: linear-gradient(135deg, #050a1b 0%, #000000 100%); color:#ffffff; }

    .shadow-soft { box-shadow: 0 10px 22px rgba(9, 9, 49, 0.08); }

    * { -webkit-tap-highlight-color: transparent; }

    @media (prefers-reduced-motion: reduce) {
      .tile { transition: none; }
    }
  </style>
</head>
<body class="min-h-dvh text-slate-900">
  <div class="max-w-xl mx-auto p-4 sm:p-6">
    <header class="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
      <div>
        <h1 class="text-4xl sm:text-5xl font-black tracking-tight">2048</h1>
        <p class="text-slate-600 mt-1">方向键/WASD 或滑动来合并数字。目标：2048。</p>
      </div>
      <div class="flex items-stretch gap-3">
        <div class="bg-white/80 backdrop-blur rounded-xl px-4 py-2 shadow-soft">
          <div class="text-xs font-semibold text-slate-500">得分</div>
          <div id="score" class="text-2xl font-extrabold tabular-nums">0</div>
        </div>
        <div class="bg-white/80 backdrop-blur rounded-xl px-4 py-2 shadow-soft">
          <div class="text-xs font-semibold text-slate-500">最高分</div>
          <div id="best" class="text-2xl font-extrabold tabular-nums">0</div>
        </div>
      </div>
    </header>

    <main class="mt-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div class="flex flex-wrap items-center gap-2">
          <button id="newGame" class="px-4 py-2 rounded-xl bg-slate-900 text-white font-semibold shadow-soft hover:bg-slate-800 active:scale-[.99]">新游戏</button>
          <button id="undo" class="px-4 py-2 rounded-xl bg-white/80 backdrop-blur font-semibold shadow-soft hover:bg-white active:scale-[.99]" title="撤销一步">撤销</button>
          <div class="text-sm text-slate-600">提示：按 <span class="font-semibold">R</span> 可快速重开。</div>
        </div>
        <label class="flex items-center gap-2 text-sm text-slate-600 font-medium">
          难度
          <select id="sizeSelect" class="text-sm rounded-lg border border-slate-200 bg-white/80 backdrop-blur px-3 py-2 shadow-soft focus:outline-none focus:ring-2 focus:ring-slate-400">
            <option value="3">3×3 · 专家</option>
            <option value="4" selected>4×4 · 经典</option>
            <option value="5">5×5 · 悠闲</option>
            <option value="6">6×6 · 休闲</option>
          </select>
        </label>
      </div>

      <section class="relative mt-4">
        <div id="board" class="board select-none" aria-label="2048 游戏棋盘" role="application"></div>

        <div id="overlay" class="absolute inset-0 hidden rounded-[14px] p-4 sm:p-6">
          <div class="absolute inset-0 rounded-[14px] bg-white/70 backdrop-blur"></div>
          <div class="relative z-10 h-full flex flex-col items-center justify-center text-center">
            <div id="overlayTitle" class="text-3xl sm:text-4xl font-black"></div>
            <div id="overlaySubtitle" class="mt-2 text-slate-700"></div>
            <div class="mt-5 flex gap-3">
              <button id="keepGoing" class="hidden px-4 py-2 rounded-xl bg-slate-900 text-white font-semibold shadow-soft hover:bg-slate-800">继续</button>
              <button id="tryAgain" class="px-4 py-2 rounded-xl bg-white font-semibold shadow-soft hover:bg-slate-50">再来一局</button>
            </div>
          </div>
        </div>
      </section>

      <footer class="mt-5 text-sm text-slate-600 leading-relaxed">
        <p><span class="font-semibold">操作</span>：方向键 / WASD；移动端在棋盘上滑动。</p>
        <p><span class="font-semibold">规则</span>：相同数字相撞合并为更大数字，得分为合并生成的数字之和。可通过右上角选择不同棋盘大小来调整难度。</p>
      </footer>
    </main>
  </div>

  <script>
    (() => {
      const DEFAULT_SIZE = 4;
      const ALLOWED_SIZES = [3, 4, 5, 6];
      const STORAGE_KEY = 'mini2048_v1';
      const BEST_PREFIX = 'mini2048_best_v1_size';

      let SIZE = DEFAULT_SIZE;

      const $board = document.getElementById('board');
      const $score = document.getElementById('score');
      const $best = document.getElementById('best');
      const $overlay = document.getElementById('overlay');
      const $overlayTitle = document.getElementById('overlayTitle');
      const $overlaySubtitle = document.getElementById('overlaySubtitle');
      const $keepGoing = document.getElementById('keepGoing');
      const $sizeSelect = document.getElementById('sizeSelect');

      const $newGame = document.getElementById('newGame');
      const $tryAgain = document.getElementById('tryAgain');
      const $undo = document.getElementById('undo');

      let state = null;
      let prevState = null; // for undo

      function clampSize(value) {
        const n = Number(value);
        return ALLOWED_SIZES.includes(n) ? n : DEFAULT_SIZE;
      }

      function syncSizeSelect() {
        if ($sizeSelect) {
          $sizeSelect.value = String(SIZE);
        }
      }

      function emptyGrid() {
        return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
      }

      function cloneGrid(grid) {
        return grid.map(row => row.slice());
      }

      function loadBest() {
        const v = Number(localStorage.getItem(BEST_PREFIX + SIZE) || '0');
        return Number.isFinite(v) ? v : 0;
      }

      function setBest(v) {
        localStorage.setItem(BEST_PREFIX + SIZE, String(v));
      }

      function saveState() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch {}
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          const s = JSON.parse(raw);
          if (!s || !Array.isArray(s.grid)) return null;
          const rows = s.grid.length;
          if (!rows) return null;
          for (let r = 0; r < rows; r++) {
            if (!Array.isArray(s.grid[r]) || s.grid[r].length !== rows) {
              return null;
            }
          }
          return s;
        } catch {
          return null;
        }
      }

      function randChoice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function getEmptyCells(grid) {
        const cells = [];
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] === 0) cells.push([r, c]);
          }
        }
        return cells;
      }

      function addRandomTile(grid) {
        const empties = getEmptyCells(grid);
        if (!empties.length) return null;
        const [r, c] = randChoice(empties);
        const value = Math.random() < 0.9 ? 2 : 4;
        grid[r][c] = value;
        return { r, c, value };
      }

      function canMove(grid) {
        if (getEmptyCells(grid).length) return true;
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const v = grid[r][c];
            if (v === 0) continue;
            if (r + 1 < SIZE && grid[r + 1][c] === v) return true;
            if (c + 1 < SIZE && grid[r][c + 1] === v) return true;
          }
        }
        return false;
      }

      function has2048(grid) {
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] === 2048) return true;
          }
        }
        return false;
      }

      function compressLine(line) {
        let arr = line.filter(v => v !== 0);
        let scoreGain = 0;
        const merges = [];
        for (let i = 0; i < arr.length - 1; i++) {
          if (arr[i] === arr[i + 1]) {
            arr[i] *= 2;
            scoreGain += arr[i];
            merges.push(i);
            arr.splice(i + 1, 1);
            // After merge, the next element to check is at current i+1 (which was i+2)
            // The loop's i++ will correctly move us there.
          }
        }
        while (arr.length < SIZE) arr.push(0);
        return { line: arr, scoreGain, merges };
      }

      function move(dir) {
        if (state.over) return false;
        if (state.won && !state.keepGoing) return false;

        const before = cloneGrid(state.grid);
        const mergeMap = Array.from({ length: SIZE }, () => Array(SIZE).fill(false));
        let gained = 0;

        function setRow(r, newRow, merges) {
          state.grid[r] = newRow;
          merges.forEach(idx => { if (idx >= 0 && idx < SIZE) mergeMap[r][idx] = true; });
        }

        function setCol(c, newCol, merges) {
          for (let r = 0; r < SIZE; r++) state.grid[r][c] = newCol[r];
          merges.forEach(idx => { if (idx >= 0 && idx < SIZE) mergeMap[idx][c] = true; });
        }

        if (dir === 'left' || dir === 'right') {
          for (let r = 0; r < SIZE; r++) {
            let row = state.grid[r].slice();
            if (dir === 'right') row.reverse();
            const res = compressLine(row);
            gained += res.scoreGain;
            let newRow = res.line;
            if (dir === 'right') {
              newRow = newRow.slice().reverse();
              res.merges = res.merges.map(i => SIZE - 1 - i);
            }
            setRow(r, newRow, res.merges);
          }
        } else {
          for (let c = 0; c < SIZE; c++) {
            let col = [];
            for (let r = 0; r < SIZE; r++) col.push(state.grid[r][c]);
            if (dir === 'down') col.reverse();
            const res = compressLine(col);
            gained += res.scoreGain;
            let newCol = res.line;
            if (dir === 'down') {
              newCol = newCol.slice().reverse();
              res.merges = res.merges.map(i => SIZE - 1 - i);
            }
            setCol(c, newCol, res.merges);
          }
        }

        const changed = JSON.stringify(before) !== JSON.stringify(state.grid);
        if (!changed) return false;

        prevState = {
          grid: before,
          score: state.score,
          won: state.won,
          over: state.over,
          keepGoing: state.keepGoing
        };

        state.score += gained;
        if (state.score > state.best) {
          state.best = state.score;
          setBest(state.best);
        }

        const spawned = addRandomTile(state.grid);
        state.last = { spawned, mergeMap };

        if (!state.keepGoing && !state.won && has2048(state.grid)) {
          state.won = true;
        }
        if (!canMove(state.grid)) {
          state.over = true;
        }

        render();
        saveState();
        return true;
      }

      function newGame(desiredSize = SIZE) {
        SIZE = clampSize(desiredSize);
        syncSizeSelect();
        prevState = null;

        state = {
          grid: emptyGrid(),
          score: 0,
          best: loadBest(),
          won: false,
          over: false,
          keepGoing: false,
          last: null,
          size: SIZE
        };

        addRandomTile(state.grid);
        addRandomTile(state.grid);

        render();
        saveState();
      }

      function undo() {
        if (!prevState) return;
        state.grid = cloneGrid(prevState.grid);
        state.score = prevState.score;
        state.won = prevState.won;
        state.over = prevState.over;
        state.keepGoing = prevState.keepGoing;
        state.last = null;
        prevState = null;
        render();
        saveState();
      }

      function formatNum(n) {
        return String(n);
      }

      function tileFontSize(value) {
        const len = String(value).length;
        if (len <= 2) return 'text-4xl sm:text-5xl';
        if (len === 3) return 'text-3xl sm:text-4xl';
        if (len === 4) return 'text-2xl sm:text-3xl';
        return 'text-xl sm:text-2xl';
      }

      function render() {
        $score.textContent = formatNum(state.score);
        $best.textContent = formatNum(state.best);

        const gap = 12;
        const boardSize = Math.min(440, Math.max(280, Math.floor((window.innerWidth - 32))));
        const cellSize = Math.floor((boardSize - gap * (SIZE + 1)) / SIZE);
        $board.style.width = boardSize + 'px';
        $board.style.height = boardSize + 'px';
        $board.style.setProperty('--gap', gap + 'px');

        const frag = document.createDocumentFragment();
        const gridWrap = document.createElement('div');
        gridWrap.className = 'relative w-full h-full';

        const bg = document.createElement('div');
        bg.className = 'absolute inset-0 grid';
        bg.style.gridTemplateColumns = `repeat(${SIZE}, ${cellSize}px)`;
        bg.style.gridTemplateRows = `repeat(${SIZE}, ${cellSize}px)`;
        bg.style.gap = gap + 'px';
        bg.style.padding = gap + 'px';
        for (let i = 0; i < SIZE * SIZE; i++) {
          const d = document.createElement('div');
          d.className = 'cell';
          bg.appendChild(d);
        }

        const tiles = document.createElement('div');
        tiles.className = 'absolute inset-0';
        tiles.style.padding = gap + 'px';

        const spawned = state.last?.spawned;
        const mergeMap = state.last?.mergeMap;

        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const v = state.grid[r][c];
            if (!v) continue;
            const tile = document.createElement('div');
            tile.className = `tile ${tileFontSize(v)} t${v}`;
            if (v > 8192) {
              tile.style.background = '#111827';
              tile.style.color = '#f9fafb';
            }
            tile.style.position = 'absolute';
            tile.style.width = cellSize + 'px';
            tile.style.height = cellSize + 'px';
            tile.style.left = (c * (cellSize + gap)) + 'px';
            tile.style.top = (r * (cellSize + gap)) + 'px';
            tile.textContent = v;

            if (spawned && spawned.r === r && spawned.c === c) {
              tile.classList.add('pop');
            } else if (mergeMap && mergeMap[r]?.[c]) {
              tile.classList.add('merge');
            }
            tiles.appendChild(tile);
          }
        }

        gridWrap.appendChild(bg);
        gridWrap.appendChild(tiles);
        frag.appendChild(gridWrap);

        $board.replaceChildren(frag);

        if (state.over) {
          showOverlay('游戏结束', '没有可移动的步了。');
          $keepGoing.classList.add('hidden');
        } else if (state.won && !state.keepGoing) {
          showOverlay('你赢了！', '达成 2048。你可以继续挑战更高分。');
          $keepGoing.classList.remove('hidden');
        } else {
          hideOverlay();
        }

        const canUndo = !!prevState;
        $undo.disabled = !canUndo;
        $undo.classList.toggle('opacity-50', !canUndo);
        $undo.classList.toggle('cursor-not-allowed', !canUndo);
        $undo.title = canUndo ? '撤销一步' : '当前没有可撤销的操作';
      }

      function showOverlay(title, subtitle) {
        $overlayTitle.textContent = title;
        $overlaySubtitle.textContent = subtitle;
        $overlay.classList.remove('hidden');
      }

      function hideOverlay() {
        $overlay.classList.add('hidden');
      }

      function keyToDir(e) {
        const k = e.key.toLowerCase();
        if (k === 'arrowleft' || k === 'a') return 'left';
        if (k === 'arrowright' || k === 'd') return 'right';
        if (k === 'arrowup' || k === 'w') return 'up';
        if (k === 'arrowdown' || k === 's') return 'down';
        return null;
      }

      window.addEventListener('keydown', (e) => {
        if (['arrowleft','arrowright','arrowup','arrowdown',' '].includes(e.key.toLowerCase())) e.preventDefault();
        if (e.key.toLowerCase() === 'r') {
          newGame(SIZE);
          return;
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
          undo();
          return;
        }
        const dir = keyToDir(e);
        if (dir) move(dir);
      }, { passive: false });

      let startX = 0, startY = 0, tracking = false;
      const SWIPE_MIN = 24;

      $board.addEventListener('pointerdown', (e) => {
        tracking = true;
        startX = e.clientX;
        startY = e.clientY;
        $board.setPointerCapture?.(e.pointerId);
      });

      $board.addEventListener('pointerup', (e) => {
        if (!tracking) return;
        tracking = false;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        const adx = Math.abs(dx);
        const ady = Math.abs(dy);
        if (Math.max(adx, ady) < SWIPE_MIN) return;
        if (adx > ady) move(dx > 0 ? 'right' : 'left');
        else move(dy > 0 ? 'down' : 'up');
      });

      $board.addEventListener('pointercancel', () => { tracking = false; });

      $newGame.addEventListener('click', () => newGame(SIZE));
      $tryAgain.addEventListener('click', () => newGame(SIZE));
      $undo.addEventListener('click', () => undo());
      $keepGoing.addEventListener('click', () => {
        state.keepGoing = true;
        hideOverlay();
        render();
        saveState();
      });

      if ($sizeSelect) {
        $sizeSelect.addEventListener('change', (e) => {
          const selected = clampSize(e.target.value);
          if (selected === SIZE) return;
          newGame(selected);
        });
      }

      window.addEventListener('resize', () => render());

      const loaded = loadState();
      if (loaded) {
        const storedSize = clampSize(loaded.size || (loaded.grid?.length ?? DEFAULT_SIZE));
        SIZE = storedSize;
        syncSizeSelect();
        if (loaded.grid.length !== SIZE) {
          newGame(SIZE);
        } else {
          state = {
            grid: loaded.grid,
            score: Number(loaded.score || 0),
            best: Math.max(loadBest(), Number(loaded.best || 0)),
            won: !!loaded.won,
            over: !!loaded.over,
            keepGoing: !!loaded.keepGoing,
            last: null,
            size: SIZE
          };
          render();
        }
      } else {
        syncSizeSelect();
        newGame(SIZE);
      }
    })();
  </script>
</body>
</html>
