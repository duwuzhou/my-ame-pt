<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>跳跃的小鸟 (Flappy Bird Clone)</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    body{margin:0;padding:0;overflow:hidden;touch-action:none;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;}
    canvas{display:block;}
    #ui-layer{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;flex-direction:column;justify-content:center;align-items:center;}
    .interactive{pointer-events:auto;}
  </style>
</head>
<body class="bg-sky-300 h-screen w-screen flex justify-center items-center relative">

  <canvas id="gameCanvas" class="shadow-2xl border-4 border-slate-800 rounded-lg bg-sky-200"></canvas>

  <div id="ui-layer">
    <div id="start-screen" class="text-center bg-white/80 p-8 rounded-xl backdrop-blur-sm shadow-lg interactive">
      <h1 class="text-4xl font-black text-yellow-500 stroke-black mb-4 drop-shadow-md" style="-webkit-text-stroke: 1px black;">跳跃的小鸟</h1>
      <p class="text-gray-700 mb-4 text-lg">按空格键 / ↑ / W 或点击屏幕跳跃</p>

      <div class="mb-6 text-left">
        <label class="block text-sm font-semibold text-slate-700 mb-2">难度选择</label>
        <div class="flex flex-wrap gap-2">
          <button data-difficulty="easy" class="difficulty-btn px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold border border-slate-200">简单</button>
          <button data-difficulty="normal" class="difficulty-btn px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold border border-slate-200">普通</button>
          <button data-difficulty="hard" class="difficulty-btn px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold border border-slate-200">困难</button>
          <button data-difficulty="custom" class="difficulty-btn px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold border border-slate-200">自定义</button>
        </div>

        <div id="custom-panel" class="hidden mt-4 p-4 rounded-lg bg-slate-50 border border-slate-200">
          <div class="grid grid-cols-2 gap-3">
            <div>
              <label class="text-xs text-slate-600">重力</label>
              <input id="custom-gravity" type="range" min="0.12" max="0.65" step="0.01" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-gravity-val"></span></div>
            </div>
            <div>
              <label class="text-xs text-slate-600">跳跃力度</label>
              <input id="custom-jump" type="range" min="-9.5" max="-3.6" step="0.1" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-jump-val"></span></div>
            </div>
            <div>
              <label class="text-xs text-slate-600">管道间隙</label>
              <input id="custom-gap" type="range" min="80" max="240" step="5" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-gap-val"></span></div>
            </div>
            <div>
              <label class="text-xs text-slate-600">管道间距</label>
              <input id="custom-spacing" type="range" min="160" max="420" step="10" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-spacing-val"></span></div>
            </div>
            <div>
              <label class="text-xs text-slate-600">初始速度</label>
              <input id="custom-speed" type="range" min="1.6" max="7.0" step="0.1" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-speed-val"></span></div>
            </div>
            <div>
              <label class="text-xs text-slate-600">加速频率(分)</label>
              <input id="custom-accEvery" type="range" min="1" max="15" step="1" class="w-full" />
              <div class="text-xs text-slate-600"><span id="custom-accEvery-val"></span></div>
            </div>
          </div>
          <p class="mt-3 text-xs text-slate-500">提示：自定义仅影响新开局；游戏中不动态改变已生成管道。</p>
        </div>
      </div>

      <button id="start-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl transition transform hover:scale-105 active:scale-95 shadow-lg border-b-4 border-green-700">开始游戏</button>
    </div>

    <div id="game-over-screen" class="hidden text-center bg-white/90 p-8 rounded-xl backdrop-blur-sm shadow-xl interactive border-4 border-red-400">
      <h2 class="text-4xl font-bold text-slate-800 mb-2">游戏结束</h2>
      <div class="flex justify-center items-center gap-4 mb-6">
        <div class="text-center">
          <p class="text-sm text-gray-500 uppercase tracking-wide">得分</p>
          <p id="final-score" class="text-3xl font-bold text-green-600">0</p>
        </div>
        <div class="w-px h-10 bg-gray-300"></div>
        <div class="text-center">
          <p class="text-sm text-gray-500 uppercase tracking-wide">最佳</p>
          <p id="best-score" class="text-3xl font-bold text-yellow-600">0</p>
        </div>
      </div>
      <div class="mb-5">
        <p class="text-sm text-slate-600">本局难度：<span id="difficulty-label" class="font-bold text-slate-800">普通</span></p>
      </div>
      <button id="restart-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-xl transition transform hover:scale-105 active:scale-95 shadow-lg border-b-4 border-blue-700">再玩一次</button>
    </div>

    <div id="score-display" class="hidden absolute top-10 text-6xl font-black text-white drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)]" style="-webkit-text-stroke: 2px black;">0</div>
  </div>

  <script>
    // --- Canvas & UI ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreDisplay = document.getElementById('score-display');
    const finalScoreEl = document.getElementById('final-score');
    const bestScoreEl = document.getElementById('best-score');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    // Difficulty UI
    const difficultyBtns = Array.from(document.querySelectorAll('.difficulty-btn'));
    const customPanel = document.getElementById('custom-panel');
    const difficultyLabel = document.getElementById('difficulty-label');
    const customGravity = document.getElementById('custom-gravity');
    const customJump = document.getElementById('custom-jump');
    const customGap = document.getElementById('custom-gap');
    const customSpacing = document.getElementById('custom-spacing');
    const customSpeed = document.getElementById('custom-speed');
    const customAccEvery = document.getElementById('custom-accEvery');
    const customGravityVal = document.getElementById('custom-gravity-val');
    const customJumpVal = document.getElementById('custom-jump-val');
    const customGapVal = document.getElementById('custom-gap-val');
    const customSpacingVal = document.getElementById('custom-spacing-val');
    const customSpeedVal = document.getElementById('custom-speed-val');
    const customAccEveryVal = document.getElementById('custom-accEvery-val');

    // --- Game State ---
    let frames = 0;
    let score = 0;
    // 修复：localStorage 取出来是字符串，必须转数字，否则比较会出错
    let highScore = Number(localStorage.getItem('flappyHighScore') || 0);
    let gameState = 'START'; // START, PLAYING, GAMEOVER
    let rafId = null;

    // --- Difficulty ---
    const DIFFICULTIES = {
      easy:   { name: '简单', gravity: 0.24, jump: -6.1, gap: 170, spacing: 285, speed: 2.7, accEvery: 6, accStep: 0.10, maxSpeed: 4.6 },
      normal: { name: '普通', gravity: 0.28, jump: -6.1, gap: 150, spacing: 260, speed: 3.0, accEvery: 5, accStep: 0.12, maxSpeed: 5.0 },
      hard:   { name: '困难', gravity: 0.32, jump: -6.0, gap: 135, spacing: 245, speed: 3.4, accEvery: 4, accStep: 0.14, maxSpeed: 5.6 },
      custom: { name: '自定义', gravity: 0.28, jump: -6.1, gap: 150, spacing: 260, speed: 3.0, accEvery: 5, accStep: 0.12, maxSpeed: 5.6 }
    };

    let difficultyKey = localStorage.getItem('flappyDifficulty') || 'normal';

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function getCustomSettingsFromUI() {
      // 修复：自定义滑块在极少数情况下可能还未初始化/没有值，做兜底
      const fallback = DIFFICULTIES.custom;
      const g = Number(customGravity?.value);
      const j = Number(customJump?.value);
      const gap = Number(customGap?.value);
      const sp = Number(customSpacing?.value);
      const speed = Number(customSpeed?.value);
      const ae = Number(customAccEvery?.value);

      return {
        name: '自定义',
        gravity: Number.isFinite(g) ? g : fallback.gravity,
        jump: Number.isFinite(j) ? j : fallback.jump,
        gap: Number.isFinite(gap) ? Math.round(gap) : fallback.gap,
        spacing: Number.isFinite(sp) ? Math.round(sp) : fallback.spacing,
        speed: Number.isFinite(speed) ? speed : fallback.speed,
        accEvery: Number.isFinite(ae) ? Math.round(ae) : fallback.accEvery,
        accStep: 0.12,
        maxSpeed: 8.5
      };
    }

    function getActiveSettings() {
      if (difficultyKey === 'custom') return getCustomSettingsFromUI();
      return DIFFICULTIES[difficultyKey] || DIFFICULTIES.normal;
    }

    function setDifficulty(nextKey, { syncUI = true } = {}) {
      difficultyKey = nextKey;
      localStorage.setItem('flappyDifficulty', difficultyKey);

      const d = getActiveSettings();
      if (difficultyLabel) difficultyLabel.textContent = d.name;

      // Toggle custom panel
      if (customPanel) {
        if (difficultyKey === 'custom') customPanel.classList.remove('hidden');
        else customPanel.classList.add('hidden');
      }

      // Visual state
      if (syncUI) {
        difficultyBtns.forEach(btn => {
          const active = btn.dataset.difficulty === difficultyKey;
          btn.classList.toggle('bg-slate-900', active);
          btn.classList.toggle('text-white', active);
          btn.classList.toggle('border-slate-900', active);
          btn.classList.toggle('bg-slate-100', !active);
          btn.classList.toggle('text-slate-700', !active);
          btn.classList.toggle('border-slate-200', !active);
        });
      }
    }

    function applyDifficultyToGame() {
      const d = getActiveSettings();
      bird.gravity = d.gravity;
      bird.jumpStrength = d.jump;
      pipes.gap = d.gap;
      pipes.spacing = d.spacing;
      pipes.dx = d.speed;
      pipes.accEvery = d.accEvery;
      pipes.accStep = d.accStep;
      pipes.maxSpeed = d.maxSpeed;

      if (difficultyLabel) difficultyLabel.textContent = d.name;
    }

    // --- Layout constants ---
    const GROUND_H = 20;

    function resizeCanvas() {
      const maxWidth = 480;
      const maxHeight = 720;

      let width = window.innerWidth;
      let height = window.innerHeight;

      if (width > maxWidth) {
        width = maxWidth;
        height = Math.min(window.innerHeight - 40, maxHeight);
      } else {
        height = window.innerHeight;
      }

      canvas.width = width;
      canvas.height = height;

      // 修复：窗口尺寸变化时，START/GAMEOVER 状态下重排小鸟位置，避免在地面里直接判死
      if (gameState !== 'PLAYING') {
        bird.reset();
        safeRedraw();
      }
    }

    window.addEventListener('resize', resizeCanvas);

    // --- Background ---
    const background = {
      drawSky() {
        // 轻微渐变天空
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, '#bae6fd');
        g.addColorStop(1, '#7dd3fc');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 云朵（简单）
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = '#ffffff';
        const t = frames * 0.3;
        drawCloud((canvas.width * 0.2 - t) % (canvas.width + 160) - 80, canvas.height * 0.18, 50);
        drawCloud((canvas.width * 0.65 - t * 0.7) % (canvas.width + 200) - 100, canvas.height * 0.28, 65);
        drawCloud((canvas.width * 0.9 - t * 0.5) % (canvas.width + 220) - 110, canvas.height * 0.12, 45);
        ctx.globalAlpha = 1;
      },
      drawGround() {
        // Ground base
        ctx.fillStyle = '#DED895';
        ctx.fillRect(0, canvas.height - GROUND_H, canvas.width, GROUND_H);
        // Grass strip
        ctx.fillStyle = '#73C02E';
        ctx.fillRect(0, canvas.height - GROUND_H - 5, canvas.width, 5);

        // Moving ground pattern
        ctx.beginPath();
        ctx.strokeStyle = '#Cbb968';
        ctx.lineWidth = 2;
        const offset = (frames * pipes.dx) % 20;
        for (let i = 0; i < canvas.width + 40; i += 20) {
          ctx.moveTo(i - offset, canvas.height - GROUND_H);
          ctx.lineTo(i - offset - 10, canvas.height);
        }
        ctx.stroke();
      }
    };

    function drawCloud(x, y, r) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.arc(x + r * 0.9, y + r * 0.1, r * 0.75, 0, Math.PI * 2);
      ctx.arc(x - r * 0.9, y + r * 0.2, r * 0.65, 0, Math.PI * 2);
      ctx.arc(x + r * 1.6, y + r * 0.25, r * 0.55, 0, Math.PI * 2);
      ctx.fill();
    }

    // --- Bird ---
    const bird = {
      x: 50,
      y: 150,
      radius: 12,
      velocity: 0,
      gravity: 0.28,
      jumpStrength: -5.8,
      rotation: 0,
      color: '#FACC15',

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, this.velocity * 0.1));
        ctx.rotate(this.rotation);

        // Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Eye
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.arc(6, -6, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(8, -6, 2, 0, Math.PI * 2);
        ctx.fill();

        // Beak
        ctx.fillStyle = '#F97316';
        ctx.beginPath();
        ctx.moveTo(6, 2);
        ctx.lineTo(16, 6);
        ctx.lineTo(6, 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Wing
        ctx.fillStyle = '#EAB308';
        ctx.beginPath();
        ctx.ellipse(-4, 4, 6, 4, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();
      },

      update() {
        this.velocity += this.gravity;
        this.y += this.velocity;

        // Floor collision
        const floorY = canvas.height - GROUND_H;
        if (this.y + this.radius >= floorY) {
          this.y = floorY - this.radius;
          this.velocity = 0;
          triggerGameOver();
        }

        // Ceiling clamp
        if (this.y - this.radius <= 0) {
          this.y = this.radius;
          this.velocity = 0;
        }
      },

      jump() {
        this.velocity = this.jumpStrength;
      },

      reset() {
        this.x = Math.round(canvas.width / 3);
        this.y = Math.round(canvas.height / 2);
        this.velocity = 0;
        this.rotation = 0;
      }
    };

    // --- Pipes ---
    const pipes = {
      items: [],
      width: 52,
      gap: 150,
      dx: 3,
      spacing: 260,
      accEvery: 5,
      accStep: 0.12,
      maxSpeed: 5,

      draw() {
        for (const p of this.items) {
          ctx.fillStyle = '#22c55e';
          ctx.strokeStyle = '#14532d';
          ctx.lineWidth = 2;

          // Top pipe body
          ctx.fillRect(p.x, 0, this.width, p.top);
          ctx.strokeRect(p.x, 0, this.width, p.top);

          // Top cap (避免 p.top < 20 时画出负高度导致闪烁)
          const topCapY = Math.max(0, p.top - 20);
          const topCapH = Math.min(20, p.top);
          ctx.fillRect(p.x - 2, topCapY, this.width + 4, topCapH);
          ctx.strokeRect(p.x - 2, topCapY, this.width + 4, topCapH);

          // Bottom pipe body
          const bottomY = canvas.height - GROUND_H - p.bottom;
          ctx.fillRect(p.x, bottomY, this.width, p.bottom);
          ctx.strokeRect(p.x, bottomY, this.width, p.bottom);

          // Bottom cap（修复：原来会画到地面下面，且高度固定 20 可能越界）
          const capH = Math.min(20, p.bottom);
          ctx.fillRect(p.x - 2, bottomY, this.width + 4, capH);
          ctx.strokeRect(p.x - 2, bottomY, this.width + 4, capH);
        }
      },

      spawnIfNeeded() {
        const last = this.items[this.items.length - 1];
        if (!last || last.x < canvas.width - this.spacing) {
          const usableH = canvas.height - GROUND_H;
          const minTop = 60;
          const maxTop = usableH - this.gap - 80;
          if (maxTop <= minTop) return;

          const top = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
          const bottom = usableH - this.gap - top;

          this.items.push({ x: canvas.width + 10, top, bottom, passed: false });
        }
      },

      update() {
        this.spawnIfNeeded();

        for (let i = 0; i < this.items.length; i++) {
          const p = this.items[i];
          p.x -= this.dx;

          if (checkCollision(p)) {
            triggerGameOver();
            return;
          }

          if (p.x + this.width < bird.x && !p.passed) {
            score++;
            scoreDisplay.innerText = String(score);
            p.passed = true;

            if (score % this.accEvery === 0) {
              this.dx = Math.min(this.dx + this.accStep, this.maxSpeed);
            }
          }

          if (p.x + this.width < -10) {
            this.items.splice(i, 1);
            i--;
          }
        }
      },

      reset() {
        this.items = [];
        // dx 会在 applyDifficultyToGame() 里设置，这里不强行覆盖
      }
    };

    function checkCollision(pipe) {
      const birdLeft = bird.x - bird.radius;
      const birdRight = bird.x + bird.radius;
      const birdTop = bird.y - bird.radius;
      const birdBottom = bird.y + bird.radius;

      const pipeLeft = pipe.x;
      const pipeRight = pipe.x + pipes.width;

      // Horizontal overlap
      if (birdRight > pipeLeft && birdLeft < pipeRight) {
        const gapTop = pipe.top;
        const gapBottom = (canvas.height - GROUND_H) - pipe.bottom;
        if (birdTop < gapTop || birdBottom > gapBottom) return true;
      }
      return false;
    }

    // --- Game flow ---
    function safeRedraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      background.drawSky();
      pipes.draw();
      bird.draw();
      background.drawGround();
    }

    function init() {
      // 修复：取消上一局的 RAF，避免多重循环造成“加速/闪烁/判定异常”
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      // 关键修复：初始化新一局前，先把“当前难度（含自定义）”固化
      // 避免出现 UI 上改了自定义，但新一局仍用旧参数的情况
      if (difficultyKey === 'custom') {
        persistCustom();
      }
      applyDifficultyToGame();

      pipes.reset();
      bird.reset();
      score = 0;
      frames = 0;
      scoreDisplay.innerText = '0';

      gameState = 'START';

      bestScoreEl.innerText = String(highScore);

      startScreen.classList.remove('hidden');
      gameOverScreen.classList.add('hidden');
      scoreDisplay.classList.add('hidden');

      safeRedraw();
    }

    function startGame() {
      if (gameState === 'PLAYING') return;

      // 关键修复：开始游戏时再次“按当前难度（含自定义滑块最新值）”应用参数
      // 这样即使玩家在开始界面调整了自定义滑块，也一定会带入新开局
      applyDifficultyToGame();
      if (difficultyKey === 'custom') {
        // 确保自定义值被保存（刷新/回到开始界面也不丢）
        persistCustom();
      }

      gameState = 'PLAYING';

      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      scoreDisplay.classList.remove('hidden');

      // 修复：开局先清一次，避免残影
      safeRedraw();
      loop();
    }

    function triggerGameOver() {
      if (gameState !== 'PLAYING') return;
      gameState = 'GAMEOVER';

      // 停止循环
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      scoreDisplay.classList.add('hidden');
      gameOverScreen.classList.remove('hidden');

      finalScoreEl.innerText = String(score);
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('flappyHighScore', String(highScore));
      }
      bestScoreEl.innerText = String(highScore);

      // 结算画面保持最后一帧
      safeRedraw();
    }

    function loop() {
      if (gameState !== 'PLAYING') return;

      frames++;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 修复：绘制层级：天空 -> 管道 -> 小鸟 -> 地面
      background.drawSky();

      bird.update();
      pipes.update();

      pipes.draw();
      bird.draw();
      background.drawGround();

      rafId = requestAnimationFrame(loop);
    }

    // --- Input ---
    function handleInput(e) {
      if (e?.type === 'keydown' && e.code === 'Space') e.preventDefault();

      if (gameState === 'START') {
        startGame();
        bird.jump();
      } else if (gameState === 'PLAYING') {
        bird.jump();
      }
    }

    function isButtonClick(target) {
      return target && (target.tagName === 'BUTTON' || target.closest?.('button'));
    }

    function isUIOverlayClick(target) {
      // 点击开始界面/自定义面板/结束界面里的任意内容都不应该触发“开始/跳跃”
      const ui = target?.closest?.('#ui-layer');
      if (!ui) return false;
      return !!target.closest?.('#start-screen, #game-over-screen, #custom-panel');
    }

    window.addEventListener('mousedown', (e) => {
      if (isButtonClick(e.target)) return;
      if (isUIOverlayClick(e.target)) return;
      handleInput(e);
    });

    window.addEventListener('touchstart', (e) => {
      if (isButtonClick(e.target)) return;
      if (isUIOverlayClick(e.target)) return;
      e.preventDefault();
      handleInput(e);
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
        handleInput(e);
      }
    });

    startBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      startGame();
      bird.jump();
    });

    restartBtn.addEventListener('click', (e) => {
      e.stopPropagation();

      // 再玩一次：回到难度设置（开始界面），让玩家可调整难度后再开始
      // 仍然先把“当前（可能是自定义滑块的最新值）”持久化/同步到标签，确保 UI 一致
      applyDifficultyToGame();

      // 重置到 START 状态并显示开始界面（不自动开局）
      init();

      // 防止按钮点击/触摸残留触发跳跃
      //（init 后已经是 START 状态；这里不做自动 startGame）
    });

    // Difficulty UI events
    function updateCustomLabels() {
      if (!customGravity) return;
      customGravityVal.textContent = Number(customGravity.value).toFixed(2);
      customJumpVal.textContent = Number(customJump.value).toFixed(1);
      customGapVal.textContent = String(Math.round(Number(customGap.value)));
      customSpacingVal.textContent = String(Math.round(Number(customSpacing.value)));
      customSpeedVal.textContent = Number(customSpeed.value).toFixed(1);
      customAccEveryVal.textContent = String(Math.round(Number(customAccEvery.value)));
    }

    function loadCustomDefaults() {
      const saved = (() => {
        try { return JSON.parse(localStorage.getItem('flappyCustomDifficulty') || 'null'); } catch { return null; }
      })();
      const base = saved || {
        gravity: DIFFICULTIES.custom.gravity,
        jump: DIFFICULTIES.custom.jump,
        gap: DIFFICULTIES.custom.gap,
        spacing: DIFFICULTIES.custom.spacing,
        speed: DIFFICULTIES.custom.speed,
        accEvery: DIFFICULTIES.custom.accEvery
      };

      customGravity.value = String(clamp(base.gravity, 0.12, 0.65));
      customJump.value = String(clamp(base.jump, -9.5, -3.6));
      customGap.value = String(clamp(base.gap, 80, 240));
      customSpacing.value = String(clamp(base.spacing, 160, 420));
      customSpeed.value = String(clamp(base.speed, 1.6, 7.0));
      customAccEvery.value = String(clamp(base.accEvery, 1, 15));

      updateCustomLabels();
    }

    function persistCustom() {
      const v = getCustomSettingsFromUI();
      localStorage.setItem('flappyCustomDifficulty', JSON.stringify({
        gravity: v.gravity,
        jump: v.jump,
        gap: v.gap,
        spacing: v.spacing,
        speed: v.speed,
        accEvery: v.accEvery
      }));
    }

    difficultyBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        setDifficulty(btn.dataset.difficulty);
        if (gameState !== 'PLAYING') {
          // 仅在未开局时即时预览（不强制重置管道，只是更新标签/自定义面板）
          applyDifficultyToGame();
          safeRedraw();
        }
      });
    });

    [customGravity, customJump, customGap, customSpacing, customSpeed, customAccEvery].forEach(el => {
      if (!el) return;
      el.addEventListener('input', () => {
        updateCustomLabels();
        persistCustom();
        if (difficultyKey === 'custom' && gameState !== 'PLAYING') {
          applyDifficultyToGame();
          safeRedraw();
        }
      });
    });

    // --- Boot ---
    resizeCanvas();
    loadCustomDefaults();

    // 修复：如果上次保存的是自定义难度，必须先 setDifficulty 才能展示面板
    // 并且需要同步一次参数与画面，让玩家立刻看到滑块生效
    setDifficulty(difficultyKey);
    applyDifficultyToGame();
    updateCustomLabels();

    init();
  </script>
</body>
</html>
